    def generate_graph_with_lookahead(self, max_num_vertices: int, lookahead: int, min_noise_reserve: int = 0):
        """
        Args:
            self:
            max_num_vertices: v_max in paper -- note this can sample above this??
            lookahead: L in paper
            min_noise_reserve:  NEW parameter to reserve some noise vertices from max_num_vertices, this effecitively
            replaces 'u' in the paper
        Returns: nx.Graph, start, end
        """

        if lookahead == 0:
            raise ValueError('Lookahead must be > 0')
        if (max_num_vertices - min_noise_reserve - 1 - lookahead) // lookahead < 1:
            raise ValueError(f'Not enough vertices to create a graph with lookahead {lookahead} '
                             f'from {max_num_vertices - min_noise_reserve}')

        class Node(object):
            def __init__(self, id):
                self.id = id
                self.children = []
                self.parents = []

            def __eq__(self, other):
                return self.id == other.id

        # sample number of paths
        max_num_paths = (max_num_vertices - min_noise_reserve - 1 - lookahead) // lookahead
        num_paths = self.rng.integers(1, max_num_paths + 1)

        # sample path lengths
        path_lengths = []
        path_noise = self.rng.integers(0, 1, num_paths)
        n = max_num_vertices - min_noise_reserve - 1 - lookahead
        for p in range(num_paths):
            l = lookahead + path_noise[p]
            if l > n:
                l = n
            path_lengths.append(l)
            n -= l

        vertices = []
        for i in range(max_num_vertices):
            vertices.append(Node(i))

        start = vertices[0]
        end = vertices[lookahead]

        # create desired path
        cur = 1
        for i in range(lookahead):
            vertices[cur].parents.append(vertices[cur - 1])
            vertices[cur -1].children.append(vertices[cur])
            cur += 1
        self.arms.append([v.id for v in vertices[1:lookahead]])

        # create other paths
        for path_length in path_lengths:
            arm = []
            vertices[cur].parents.append(vertices[0])
            vertices[0].children.append(vertices[cur])
            arm.append(vertices[cur].id)
            cur += 1
            for _ in range(1, path_length):
                vertices[cur].parents.append(vertices[cur - 1])
                vertices[cur - 1].children.append(vertices[cur])
                arm.append(vertices[cur].id)
                cur += 1
            self.arms.append(arm)

        # create in path
        if cur < max_num_vertices - 1:
            num_prefix_vertices = self.rng.integers(0, lookahead + 1)
            num_prefix_vertices = min(num_prefix_vertices, max_num_vertices - cur - 1)
            prev_vertex = vertices[0]
            arm = []
            for _ in range(num_prefix_vertices):  # build in arm
                vertices[cur].children.append(prev_vertex)
                prev_vertex.parents.append(vertices[cur])
                prev_vertex = vertices[cur]
                arm.append(prev_vertex.id)
                cur += 1
            self.arms.append(arm)

        # sample some parent/ancestor vertices
        alpha = 0.5
        in_degrees = np.array([alpha + len(vertex.parents) for vertex in vertices[:max_num_vertices]])
        out_degrees = np.array([alpha + len(vertex.children) for vertex in vertices[:max_num_vertices]])
        for i in range(cur, max_num_vertices):
            # sample the number of child and parent vertices
            num_children = self.rng.integers(0, self.max_num_parents)
            num_parents = self.rng.integers(0 if num_children != 0 else 1, self.max_num_parents)
            num_children = min(num_children, i)
            num_parents = min(num_parents, i)

            # sample the children of this new node
            probabilities = in_degrees[:cur].copy()
            probabilities /= np.sum(probabilities)
            for child_id in np.random.choice(cur, num_children, replace=False, p=probabilities):
                vertices[cur].children.append(vertices[child_id])
                vertices[child_id].parents.append(vertices[cur])
                in_degrees[child_id] += 1

            # to avoid creating a cycle, we have to remove any descendants from the possible parents
            descendants = self.get_descendants(vertices[cur])
            probabilities = out_degrees[:cur].copy()

            for descendant in descendants:
                probabilities[descendant.id] = 0
            total_probability = np.sum(probabilities)
            if total_probability != 0.0:
                probabilities /= total_probability
                num_parents = min(num_parents, cur - len(descendants))

                # sample the parents of this new node
                for parent_id in np.random.choice(cur, num_parents, replace=False, p=probabilities):
                    vertices[parent_id].children.append(vertices[i])
                    vertices[i].parents.append(vertices[parent_id])
                    out_degrees[parent_id] += 1
            cur += 1

        # convert to nx
        G = nx.DiGraph()
        for vertex in vertices:
            G.add_node(vertex.id)
        for vertex in vertices:
            for child in vertex.children:
                G.add_edge(vertex.id, child.id)

        # print(len(G.nodes) > max_num_vertices, len(G.nodes), max_num_vertices, lookahead)
        return G, start.id, end.id